<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#8B5CF6">
    <title>Pok√©Run - Legendary Journey Tracker</title>

```
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<style>
    /* Mobile optimizations */
    * {
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
    }
    
    body {
        overscroll-behavior: none;
        -webkit-font-smoothing: antialiased;
    }
    
    input {
        font-size: 16px !important; /* Prevents iOS zoom */
    }
    
    button {
        cursor: pointer;
        -webkit-touch-callout: none;
    }
    
    /* PWA loading screen */
    #loading {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        transition: opacity 0.3s;
    }
    
    #loading.hidden {
        opacity: 0;
        pointer-events: none;
    }
    
    .loader {
        width: 50px;
        height: 50px;
        border: 4px solid rgba(255,255,255,0.3);
        border-top-color: white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>
```

</head>
<body>
    <div id="loading">
        <div class="loader"></div>
    </div>
    <div id="root"></div>

```
<script type="text/babel">
    console.log('Script starting...');
    const { useState, useRef, useEffect } = React;
    console.log('React loaded:', !!React);

    // Storage API
    if (!window.storage) {
        window.storage = {
            async get(key) {
                const value = localStorage.getItem(key);
                return value ? { key, value, shared: false } : null;
            },
            async set(key, value) {
                localStorage.setItem(key, value);
                return { key, value, shared: false };
            }
        };
    }

    const PokemonRunTracker = () => {
        const [pace, setPace] = useState('');
        const [distance, setDistance] = useState('');
        const [duration, setDuration] = useState('');
        const [pokemonData, setPokemonData] = useState(null);
        const [spriteVariant, setSpriteVariant] = useState('default');
        const [availableVariants, setAvailableVariants] = useState([]);
        const [isShiny, setIsShiny] = useState(false);
        
        // Auto-calculate third value ONLY when two are entered and third is empty
        const isFieldEmpty = (value) => {
            return !value || value === '' || value === '0' || value === '0:00' || value === '0.0';
        };
        
        const handlePaceChange = (value) => {
            setPace(value);
            
            // Only calculate duration if it's currently empty
            if (distance && value && isFieldEmpty(duration)) {
                const [min, sec] = value.split(':').map(Number);
                if (!isNaN(min) && !isNaN(sec)) {
                    const paceSeconds = min * 60 + (sec || 0);
                    const dist = parseFloat(distance);
                    if (!isNaN(dist) && dist > 0) {
                        const totalSeconds = paceSeconds * dist;
                        const durMin = Math.floor(totalSeconds / 60);
                        const durSec = Math.round(totalSeconds % 60);
                        setDuration(`${durMin}:${durSec.toString().padStart(2, '0')}`);
                    }
                }
            }
        };

        const handleDistanceChange = (value) => {
            setDistance(value);
            const dist = parseFloat(value);
            
            // Priority 1: If pace is empty but we have duration, calculate pace
            if (isFieldEmpty(pace) && !isFieldEmpty(duration) && !isNaN(dist) && dist > 0) {
                const [durMin, durSec] = duration.split(':').map(Number);
                if (!isNaN(durMin) && !isNaN(durSec)) {
                    const totalSeconds = durMin * 60 + (durSec || 0);
                    const paceSeconds = totalSeconds / dist;
                    const paceMin = Math.floor(paceSeconds / 60);
                    const paceSec = Math.round(paceSeconds % 60);
                    setPace(`${paceMin}:${paceSec.toString().padStart(2, '0')}`);
                }
            }
            // Priority 2: If duration is empty but we have pace, calculate duration
            else if (isFieldEmpty(duration) && !isFieldEmpty(pace) && !isNaN(dist) && dist > 0) {
                const [paceMin, paceSec] = pace.split(':').map(Number);
                if (!isNaN(paceMin) && !isNaN(paceSec)) {
                    const paceSeconds = paceMin * 60 + (paceSec || 0);
                    const totalSeconds = paceSeconds * dist;
                    const durMin = Math.floor(totalSeconds / 60);
                    const durSec = Math.round(totalSeconds % 60);
                    setDuration(`${durMin}:${durSec.toString().padStart(2, '0')}`);
                }
            }
        };

        const handleDurationChange = (value) => {
            setDuration(value);
            
            // Only calculate pace if it's currently empty
            if (distance && value && isFieldEmpty(pace)) {
                const [min, sec] = value.split(':').map(Number);
                if (!isNaN(min) && !isNaN(sec)) {
                    const totalSeconds = min * 60 + (sec || 0);
                    const dist = parseFloat(distance);
                    if (!isNaN(dist) && dist > 0) {
                        const paceSeconds = totalSeconds / dist;
                        const paceMin = Math.floor(paceSeconds / 60);
                        const paceSec = Math.round(paceSeconds % 60);
                        setPace(`${paceMin}:${paceSec.toString().padStart(2, '0')}`);
                    }
                }
            }
        };
        
        const [runHistory, setRunHistory] = useState([]);
        const [currentStreak, setCurrentStreak] = useState({ days: 0, weeks: 0 });
        const [personalRecords, setPersonalRecords] = useState({
            fastestPace: null,
            longestDistance: null,
            longestDuration: null
        });
        const [rarityRoll, setRarityRoll] = useState(null);
        const [isNewPR, setIsNewPR] = useState({});
        
        const [currentJourney, setCurrentJourney] = useState(null);
        const [journeyHistory, setJourneyHistory] = useState([]);
        const [showJourneyModal, setShowJourneyModal] = useState(false);
        const [completedJourney, setCompletedJourney] = useState(null);
        const [isLoading, setIsLoading] = useState(false);
        
        const canvasRef = useRef(null);
        const journeyCanvasRef = useRef(null);

        useEffect(() => {
            loadRunHistory();
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 500);
        }, []);

        const loadRunHistory = async () => {
            try {
                const historyResult = await window.storage.get('run-history');
                const streakResult = await window.storage.get('current-streak');
                const prResult = await window.storage.get('personal-records');
                const journeyResult = await window.storage.get('current-journey');
                const journeyHistoryResult = await window.storage.get('journey-history');
                
                if (historyResult?.value) setRunHistory(JSON.parse(historyResult.value));
                if (streakResult?.value) setCurrentStreak(JSON.parse(streakResult.value));
                if (prResult?.value) setPersonalRecords(JSON.parse(prResult.value));
                if (journeyResult?.value) setCurrentJourney(JSON.parse(journeyResult.value));
                if (journeyHistoryResult?.value) setJourneyHistory(JSON.parse(journeyHistoryResult.value));
            } catch (error) {
                console.log('Starting fresh');
            }
        };

        const saveRunHistory = async (newRun) => {
            const updatedHistory = [...runHistory, newRun];
            await window.storage.set('run-history', JSON.stringify(updatedHistory));
            setRunHistory(updatedHistory);
        };

        const updateStreak = async () => {
            const today = new Date().toDateString();
            const lastRun = runHistory.length > 0 ? new Date(runHistory[runHistory.length - 1].date).toDateString() : null;
            
            let newStreak = { ...currentStreak };
            
            if (lastRun === today) return currentStreak;
            
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = yesterday.toDateString();
            
            if (lastRun === yesterdayStr || runHistory.length === 0) {
                newStreak.days = currentStreak.days + 1;
                if (newStreak.days % 7 === 0) {
                    newStreak.weeks = Math.floor(newStreak.days / 7);
                }
            } else {
                newStreak = { days: 1, weeks: 0 };
            }
            
            await window.storage.set('current-streak', JSON.stringify(newStreak));
            setCurrentStreak(newStreak);
            return newStreak;
        };

        const checkForPRs = (paceSeconds, distanceNum, durationSeconds) => {
            const newPRs = {};
            if (!personalRecords.fastestPace || paceSeconds < personalRecords.fastestPace) {
                newPRs.fastestPace = true;
            }
            if (!personalRecords.longestDistance || distanceNum > personalRecords.longestDistance) {
                newPRs.longestDistance = true;
            }
            if (!personalRecords.longestDuration || durationSeconds > personalRecords.longestDuration) {
                newPRs.longestDuration = true;
            }
            setIsNewPR(newPRs);
            return newPRs;
        };

        const updatePersonalRecords = async (paceSeconds, distanceNum, durationSeconds) => {
            const newPRs = {
                fastestPace: !personalRecords.fastestPace ? paceSeconds : Math.min(personalRecords.fastestPace, paceSeconds),
                longestDistance: !personalRecords.longestDistance ? distanceNum : Math.max(personalRecords.longestDistance, distanceNum),
                longestDuration: !personalRecords.longestDuration ? durationSeconds : Math.max(personalRecords.longestDuration, durationSeconds)
            };
            await window.storage.set('personal-records', JSON.stringify(newPRs));
            setPersonalRecords(newPRs);
        };

        const updateJourney = async (runData, isLegendary = false, fetchedPokemonData = null) => {
            let journey = currentJourney;
            
            if (!journey) {
                journey = {
                    startDate: new Date().toISOString(),
                    runs: [],
                    totalDistance: 0,
                    totalDuration: 0,
                    bestPace: null,
                    prCount: 0,
                    maxStreak: 0,
                    legendaryEncounters: 0
                };
            }
            
            journey.runs.push(runData);
            journey.totalDistance += runData.distance;
            journey.totalDuration += runData.duration;
            journey.bestPace = !journey.bestPace ? runData.pace : Math.min(journey.bestPace, runData.pace);
            journey.prCount += runData.newPRs.length;
            journey.maxStreak = Math.max(journey.maxStreak, currentStreak.days);
            
            if (isLegendary) {
                journey.legendaryEncounters++;
                journey.endDate = new Date().toISOString();
                // ‚úÖ Use the passed pokemonName from runData instead of relying on state
                journey.legendary = {
                    id: runData.pokemonId,
                    name: runData.pokemonName || fetchedPokemonData?.name || 'unknown',
                    isShiny: runData.isShiny
                };
                
                const completedJourneyData = { ...journey };
                setCompletedJourney(completedJourneyData);
                
                const updatedJourneyHistory = [...journeyHistory, completedJourneyData];
                await window.storage.set('journey-history', JSON.stringify(updatedJourneyHistory));
                setJourneyHistory(updatedJourneyHistory);
                
                await window.storage.set('current-journey', 'null');
                setCurrentJourney(null);
                setShowJourneyModal(true);
                
                return completedJourneyData;
            } else {
                await window.storage.set('current-journey', JSON.stringify(journey));
                setCurrentJourney(journey);
                return journey;
            }
        };

        const calculateIntensity = (paceSeconds, distanceNum, durationSeconds) => {
            let intensity = 0;
            if (paceSeconds < 360) intensity += 40;
            else if (paceSeconds < 420) intensity += 35;
            else if (paceSeconds < 480) intensity += 30;
            else if (paceSeconds < 540) intensity += 25;
            else if (paceSeconds < 600) intensity += 20;
            else intensity += 15;
            
            if (distanceNum >= 26.2) intensity += 40;
            else if (distanceNum >= 13.1) intensity += 35;
            else if (distanceNum >= 10) intensity += 30;
            else if (distanceNum >= 6.2) intensity += 25;
            else if (distanceNum >= 3.1) intensity += 20;
            else if (distanceNum >= 1) intensity += 15;
            else intensity += 10;
            
            const minutes = durationSeconds / 60;
            if (minutes >= 120) intensity += 20;
            else if (minutes >= 60) intensity += 17;
            else if (minutes >= 30) intensity += 14;
            else intensity += 10;
            
            return Math.min(100, intensity);
        };

        const RARITY_TIERS = {
            common: { name: 'Common', minGen: 1, maxGen: 2, color: 'gray', chance: 0.50 },
            uncommon: { name: 'Uncommon', minGen: 3, maxGen: 4, color: 'green', chance: 0.30 },
            rare: { name: 'Rare', minGen: 5, maxGen: 6, color: 'blue', chance: 0.15 },
            epic: { name: 'Epic', minGen: 7, maxGen: 8, color: 'purple', chance: 0.04 },
            legendary: { name: 'Legendary', minGen: 1, maxGen: 9, legendary: true, color: 'orange', chance: 0.01 }
        };

        const calculateRarityChances = (intensity, streak, newPRs) => {
            let chances = { ...RARITY_TIERS };
            const intensityMultiplier = 1 + (intensity / 50);
            const dayStreakMultiplier = 1 + (Math.min(streak.days, 30) * 0.05);
            const weekStreakMultiplier = 1 + (Math.min(streak.weeks, 10) * 0.1);
            const prCount = Object.values(newPRs).filter(Boolean).length;
            const prMultiplier = 1 + (prCount * 0.5);
            const totalMultiplier = intensityMultiplier * dayStreakMultiplier * weekStreakMultiplier * prMultiplier;
            
            const adjustedChances = {
                common: { ...chances.common, chance: Math.max(0.1, chances.common.chance / totalMultiplier) },
                uncommon: { ...chances.uncommon, chance: chances.uncommon.chance * 1.2 },
                rare: { ...chances.rare, chance: chances.rare.chance * totalMultiplier * 0.8 },
                epic: { ...chances.epic, chance: chances.epic.chance * totalMultiplier * 1.2 },
                legendary: { ...chances.legendary, chance: Math.min(0.25, chances.legendary.chance * totalMultiplier * 2) }
            };
            
            const total = Object.values(adjustedChances).reduce((sum, tier) => sum + tier.chance, 0);
            Object.keys(adjustedChances).forEach(key => {
                adjustedChances[key].chance = adjustedChances[key].chance / total;
            });
            
            return { chances: adjustedChances, multiplier: totalMultiplier };
        };

        const rollRarity = (chances) => {
            const roll = Math.random();
            let cumulative = 0;
            for (const [tier, data] of Object.entries(chances)) {
                cumulative += data.chance;
                if (roll <= cumulative) return { tier, ...data };
            }
            return { tier: 'common', ...chances.common };
        };

        const LEGENDARY_IDS = [144, 145, 146, 150, 151, 243, 244, 245, 249, 250, 377, 378, 379, 380, 381, 382, 383, 384, 480, 481, 482, 483, 484, 485, 486, 487, 488, 638, 639, 640, 641, 642, 643, 644, 645, 646, 716, 717, 718, 785, 786, 787, 788, 789, 790, 791, 792, 888, 889, 890, 891, 892, 894, 895, 896, 897, 898];

        const getPokemonByRarity = async (rarity) => {
            let pokemonId;
            if (rarity.tier === 'legendary') {
                pokemonId = LEGENDARY_IDS[Math.floor(Math.random() * LEGENDARY_IDS.length)];
            } else {
                const genStart = (rarity.minGen - 1) * 151 + 1;
                const genEnd = rarity.maxGen * 151;
                pokemonId = Math.floor(Math.random() * (genEnd - genStart + 1)) + genStart;
                pokemonId = Math.min(898, pokemonId);
            }
            
            const baseShinyChance = 1/4096;
            const streakBonus = currentStreak.days * (1/500);
            const shinyChance = Math.min(0.1, baseShinyChance + streakBonus);
            const isShinyRoll = Math.random() < shinyChance;
            setIsShiny(isShinyRoll);
            
            return { pokemonId, isShiny: isShinyRoll, shinyChance };
        };

        const generatePokemon = async () => {
            setIsLoading(true);
            try {
                const [paceMin, paceSec] = pace.split(':').map(Number);
                const paceSeconds = (paceMin * 60) + (paceSec || 0);
                const distanceNum = parseFloat(distance);
                const [durMin, durSec] = duration.split(':').map(Number);
                const durationSeconds = (durMin * 60) + (durSec || 0);
                
                const newPRs = checkForPRs(paceSeconds, distanceNum, durationSeconds);
                const updatedStreak = await updateStreak();
                const intensity = calculateIntensity(paceSeconds, distanceNum, durationSeconds);
                const { chances, multiplier } = calculateRarityChances(intensity, updatedStreak, newPRs);
                const rarity = rollRarity(chances);
                const { pokemonId, isShiny, shinyChance } = await getPokemonByRarity(rarity);
                
                // ‚úÖ Fetch Pokemon data and capture the returned data
                const fetchedPokemonData = await fetchPokemonData(pokemonId);
                
                const newRun = {
                    date: new Date().toISOString(),
                    pace: paceSeconds,
                    distance: distanceNum,
                    duration: durationSeconds,
                    intensity,
                    rarity: rarity.tier,
                    pokemonId,
                    pokemonName: fetchedPokemonData?.name || 'unknown', // ‚úÖ Store name in run data
                    isShiny,
                    newPRs: Object.keys(newPRs).filter(key => newPRs[key])
                };
                
                await saveRunHistory(newRun);
                await updatePersonalRecords(paceSeconds, distanceNum, durationSeconds);
                
                const isLegendary = rarity.tier === 'legendary';
                
                setRarityRoll({
                    tier: rarity.tier,
                    color: rarity.color,
                    intensity,
                    multiplier,
                    chances,
                    shinyChance: (shinyChance * 100).toFixed(2)
                });
                
                // ‚úÖ Pass the fetched data directly to updateJourney
                await updateJourney(newRun, isLegendary, fetchedPokemonData);
                setIsLoading(false);
            } catch (error) {
                console.error('Error:', error);
                setIsLoading(false);
            }
        };

        const fetchPokemonData = async (pokemonId) => {
            try {
                const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${pokemonId}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                setPokemonData(data);

                const variants = [];
                if (data.sprites.front_default) variants.push({ name: 'Default', key: 'front_default', url: data.sprites.front_default });
                if (data.sprites.front_shiny) variants.push({ name: 'Shiny ‚ú®', key: 'front_shiny', url: data.sprites.front_shiny });
                
                setAvailableVariants(variants);
                setSpriteVariant(isShiny && data.sprites.front_shiny ? 'front_shiny' : variants[0]?.key || 'front_default');
                
                return data; // ‚úÖ Return data to avoid race condition
            } catch (error) {
                console.error('Error fetching Pokemon:', error);
                return null;
            }
        };

        useEffect(() => {
            if (pokemonData) generateImage();
        }, [pokemonData, spriteVariant]);

        const getCurrentSpriteUrl = () => {
            if (!pokemonData) return null;
            const variant = availableVariants.find(v => v.key === spriteVariant);
            return variant ? variant.url : pokemonData.sprites.front_default;
        };

        const generateImage = () => {
            const canvas = canvasRef.current;
            if (!canvas || !pokemonData) return;

            const ctx = canvas.getContext('2d');
            const width = 1080;
            const height = 1080;
            canvas.width = width;
            canvas.height = height;

            ctx.fillStyle = '#C5C9B8';
            ctx.fillRect(0, 0, width, height);

            const spriteUrl = getCurrentSpriteUrl();
            if (spriteUrl) {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    const scale = 6;
                    const spriteWidth = img.width * scale;
                    const spriteHeight = img.height * scale;
                    const spriteX = (width - spriteWidth) / 2;
                    const spriteY = 220;
                    
                    // Pokemon name above sprite (null-safe)
                    if (pokemonData?.name) {
                        ctx.fillStyle = '#000000';
                        ctx.font = 'bold 48px Arial';
                        ctx.textAlign = 'center';
                        const pokemonName = pokemonData.name.toUpperCase();
                        ctx.fillText(pokemonName, width / 2, spriteY - 40);
                    }
                    
                    ctx.imageSmoothingEnabled = false;
                    
                    if (isShiny) {
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 30;
                        for (let i = 0; i < 5; i++) {
                            ctx.drawImage(img, spriteX, spriteY, spriteWidth, spriteHeight);
                        }
                        ctx.shadowBlur = 0;
                    }
                    
                    ctx.drawImage(img, spriteX, spriteY, spriteWidth, spriteHeight);
                    
                    // Draw rarity icon (TCG style)
                    if (rarityRoll) {
                        const iconSize = 60;
                        const iconX = width / 2 - iconSize / 2;
                        const iconY = spriteY - 120;
                        
                        drawRarityIcon(ctx, iconX, iconY, iconSize, rarityRoll.tier);
                    }
                    
                    ctx.fillStyle = '#666666';
                    ctx.font = '20px monospace';
                    ctx.textAlign = 'left';
                    const timestamp = new Date().toLocaleString();
                    ctx.fillText(timestamp, spriteX - 60, spriteY + spriteHeight + 100);
                    
                    drawStatsBox(ctx, width, height);
                };
                img.onerror = () => {
                    console.error('Failed to load sprite image');
                };
                img.src = spriteUrl;
            }
        };

        const drawRarityIcon = (ctx, x, y, size, tier) => {
            ctx.save();
            
            switch(tier) {
                case 'common':
                    // Circle
                    ctx.fillStyle = '#6B7280';
                    ctx.beginPath();
                    ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    break;
                    
                case 'uncommon':
                    // Diamond
                    ctx.fillStyle = '#10B981';
                    ctx.beginPath();
                    ctx.moveTo(x + size/2, y);
                    ctx.lineTo(x + size, y + size/2);
                    ctx.lineTo(x + size/2, y + size);
                    ctx.lineTo(x, y + size/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    break;
                    
                case 'rare':
                    // Star
                    ctx.fillStyle = '#3B82F6';
                    drawStar(ctx, x + size/2, y + size/2, 5, size/2, size/4);
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    break;
                    
                case 'epic':
                    // Double Star
                    ctx.fillStyle = '#8B5CF6';
                    ctx.globalAlpha = 0.7;
                    drawStar(ctx, x + size/2 - 8, y + size/2, 5, size/2.2, size/4.4);
                    ctx.globalAlpha = 1;
                    drawStar(ctx, x + size/2 + 8, y + size/2, 5, size/2.2, size/4.4);
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;
                    
                case 'legendary':
                    // Crown/Triple Star
                    ctx.fillStyle = '#F59E0B';
                    drawStar(ctx, x + size/2, y + size/3, 5, size/2.5, size/5);
                    drawStar(ctx, x + size/4, y + size*2/3, 5, size/3, size/6);
                    drawStar(ctx, x + size*3/4, y + size*2/3, 5, size/3, size/6);
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;
            }
            
            ctx.restore();
        };

        const drawStar = (ctx, cx, cy, spikes, outerRadius, innerRadius) => {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        };

        const getRarityColor = (color) => {
            const colors = { gray: '#6B7280', green: '#10B981', blue: '#3B82F6', purple: '#8B5CF6', orange: '#F59E0B' };
            return colors[color] || colors.gray;
        };

        const drawStatsBox = (ctx, width, height) => {
            const boxWidth = 800;
            const boxHeight = 240;
            const boxX = (width - boxWidth) / 2;
            const boxY = height - 320;

            ctx.fillStyle = '#000000';
            ctx.fillRect(boxX - 8, boxY - 8, boxWidth + 16, boxHeight + 16);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(boxX - 4, boxY - 4, boxWidth + 8, boxHeight + 8);
            ctx.fillStyle = '#E8E8D0';
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

            ctx.fillStyle = '#000000';
            ctx.font = 'bold 52px Arial';
            ctx.textAlign = 'left';
            
            const padding = 50;
            let textY = boxY + padding + 45;
            
            ctx.fillText(`Avg Pace ${pace} min/mi`, boxX + padding, textY);
            textY += 75;
            ctx.fillText(`Distance ${distance} mi`, boxX + padding, textY);
            textY += 75;
            ctx.fillText(`Duration ${duration}`, boxX + padding, textY);
        };

        const downloadImage = async () => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            
            try {
                // Convert canvas to blob
                canvas.toBlob(async (blob) => {
                    if (!blob) return;
                    
                    // Use Web Share API if available (works on mobile)
                    if (navigator.share && navigator.canShare) {
                        const file = new File([blob], `pokerun-${pokemonData?.name || 'pokemon'}.png`, { type: 'image/png' });
                        
                        if (navigator.canShare({ files: [file] })) {
                            try {
                                await navigator.share({
                                    files: [file],
                                    title: 'My Pok√©Run',
                                    text: `Caught ${pokemonData?.name}!`
                                });
                                return;
                            } catch (err) {
                                console.log('Share cancelled or failed:', err);
                            }
                        }
                    }
                    
                    // Fallback to download
                    const link = document.createElement('a');
                    link.download = `pokerun-${pokemonData?.name || 'pokemon'}.png`;
                    link.href = canvas.toDataURL();
                    link.click();
                }, 'image/png');
            } catch (error) {
                console.error('Error sharing:', error);
                // Final fallback
                const link = document.createElement('a');
                link.download = `pokerun-${pokemonData?.name || 'pokemon'}.png`;
                link.href = canvas.toDataURL();
                link.click();
            }
        };

        return (
            <div className="min-h-screen bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 p-4 pb-20">
                <div className="max-w-2xl mx-auto">
                    <div className="text-center mb-6">
                        <h1 className="text-3xl md:text-4xl font-bold bg-gradient-to-r from-indigo-600 via-purple-600 to-pink-600 bg-clip-text text-transparent mb-2">
                            Pok√©Run Journey
                        </h1>
                        <p className="text-sm text-gray-600">Track runs ‚Ä¢ Catch Pok√©mon ‚Ä¢ Complete journeys</p>
                    </div>

                    {/* Compact Stats */}
                    <div className="grid grid-cols-2 gap-3 mb-6">
                        <div className="bg-gradient-to-br from-orange-500 to-red-500 rounded-xl p-3 text-white shadow-lg">
                            <div className="text-xs font-semibold mb-1">üî• Streak</div>
                            <div className="text-2xl font-bold">{currentStreak.days}d</div>
                        </div>
                        <div className="bg-gradient-to-br from-purple-500 to-pink-500 rounded-xl p-3 text-white shadow-lg">
                            <div className="text-xs font-semibold mb-1">üèÉ Runs</div>
                            <div className="text-2xl font-bold">{runHistory.length}</div>
                        </div>
                    </div>

                    {/* Input Form */}
                    <div className="bg-white rounded-2xl shadow-lg p-6 mb-6">
                        <h2 className="text-xl font-bold text-gray-800 mb-4">Your Run</h2>
                        
                        <div className="space-y-4">
                            <div>
                                <label className="block text-sm font-semibold text-gray-700 mb-2">Pace (min/mi)</label>
                                <input type="text" value={pace} onChange={(e) => handlePaceChange(e.target.value)} 
                                       className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-lg" placeholder="8:53" />
                            </div>

                            <div>
                                <label className="block text-sm font-semibold text-gray-700 mb-2">Distance (miles)</label>
                                <input type="text" value={distance} onChange={(e) => handleDistanceChange(e.target.value)}
                                       className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-lg" placeholder="1.82" />
                            </div>

                            <div>
                                <label className="block text-sm font-semibold text-gray-700 mb-2">Duration (mm:ss)</label>
                                <input type="text" value={duration} onChange={(e) => handleDurationChange(e.target.value)}
                                       className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-lg" placeholder="16:27" />
                            </div>

                            <button onClick={generatePokemon} disabled={isLoading}
                                className="w-full py-4 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white rounded-lg font-bold text-lg transition shadow-lg disabled:opacity-50">
                                {isLoading ? '‚è≥ Rolling...' : '‚ú® Roll for Pok√©mon!'}
                            </button>
                        </div>
                    </div>

                    {/* Results */}
                    {pokemonData && (
                        <div className="bg-white rounded-2xl shadow-lg p-6">
                            <div className="flex justify-between items-center mb-4">
                                <h2 className="text-xl font-bold capitalize">{pokemonData.name}</h2>
                                {isShiny && <span className="px-3 py-1 bg-yellow-400 text-white rounded-lg font-bold text-sm">‚ú® SHINY</span>}
                            </div>
                            
                            <div className="bg-gray-100 rounded-lg p-4 mb-4">
                                <canvas ref={canvasRef} className="w-full h-auto rounded-lg" style={{ maxHeight: '400px' }} />
                            </div>

                            <button onClick={downloadImage}
                                className="w-full py-3 bg-black hover:bg-gray-900 text-white rounded-lg font-medium transition">
                                Share your PokeRun
                            </button>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    console.log('Root created, attempting render...');
    root.render(<PokemonRunTracker />);
    console.log('Render called successfully');
</script>
```

</body>
</html>