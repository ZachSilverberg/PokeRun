<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#8B5CF6">
    <title>Pok√©Run - Legendary Journey Tracker</title>
    
    <link rel="manifest" href="manifest.json">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Mobile optimizations */
        * {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        body {
            overscroll-behavior: none;
            -webkit-font-smoothing: antialiased;
        }
        
        input {
            font-size: 16px !important; /* Prevents iOS zoom */
        }
        
        button {
            cursor: pointer;
            -webkit-touch-callout: none;
        }
        
        /* PWA loading screen */
        #loading {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.3s;
        }
        
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loader {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loader"></div>
    </div>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // Storage API
        if (!window.storage) {
            window.storage = {
                async get(key) {
                    const value = localStorage.getItem(key);
                    return value ? { key, value, shared: false } : null;
                },
                async set(key, value) {
                    localStorage.setItem(key, value);
                    return { key, value, shared: false };
                }
            };
        }

        const PokemonRunTracker = () => {
            const [pace, setPace] = useState('8:53');
            const [distance, setDistance] = useState('1.82');
            const [duration, setDuration] = useState('16:27');
            const [pokemonData, setPokemonData] = useState(null);
            const [spriteVariant, setSpriteVariant] = useState('default');
            const [availableVariants, setAvailableVariants] = useState([]);
            const [isShiny, setIsShiny] = useState(false);
            
            const [runHistory, setRunHistory] = useState([]);
            const [currentStreak, setCurrentStreak] = useState({ days: 0, weeks: 0 });
            const [personalRecords, setPersonalRecords] = useState({
                fastestPace: null,
                longestDistance: null,
                longestDuration: null
            });
            const [rarityRoll, setRarityRoll] = useState(null);
            const [isNewPR, setIsNewPR] = useState({});
            
            const [currentJourney, setCurrentJourney] = useState(null);
            const [journeyHistory, setJourneyHistory] = useState([]);
            const [showJourneyModal, setShowJourneyModal] = useState(false);
            const [completedJourney, setCompletedJourney] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            
            const canvasRef = useRef(null);
            const journeyCanvasRef = useRef(null);

            useEffect(() => {
                loadRunHistory();
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                }, 500);
            }, []);

            const loadRunHistory = async () => {
                try {
                    const historyResult = await window.storage.get('run-history');
                    const streakResult = await window.storage.get('current-streak');
                    const prResult = await window.storage.get('personal-records');
                    const journeyResult = await window.storage.get('current-journey');
                    const journeyHistoryResult = await window.storage.get('journey-history');
                    
                    if (historyResult?.value) setRunHistory(JSON.parse(historyResult.value));
                    if (streakResult?.value) setCurrentStreak(JSON.parse(streakResult.value));
                    if (prResult?.value) setPersonalRecords(JSON.parse(prResult.value));
                    if (journeyResult?.value) setCurrentJourney(JSON.parse(journeyResult.value));
                    if (journeyHistoryResult?.value) setJourneyHistory(JSON.parse(journeyHistoryResult.value));
                } catch (error) {
                    console.log('Starting fresh');
                }
            };

            const saveRunHistory = async (newRun) => {
                const updatedHistory = [...runHistory, newRun];
                await window.storage.set('run-history', JSON.stringify(updatedHistory));
                setRunHistory(updatedHistory);
            };

            const updateStreak = async () => {
                const today = new Date().toDateString();
                const lastRun = runHistory.length > 0 ? new Date(runHistory[runHistory.length - 1].date).toDateString() : null;
                
                let newStreak = { ...currentStreak };
                
                if (lastRun === today) return currentStreak;
                
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toDateString();
                
                if (lastRun === yesterdayStr || runHistory.length === 0) {
                    newStreak.days = currentStreak.days + 1;
                    if (newStreak.days % 7 === 0) {
                        newStreak.weeks = Math.floor(newStreak.days / 7);
                    }
                } else {
                    newStreak = { days: 1, weeks: 0 };
                }
                
                await window.storage.set('current-streak', JSON.stringify(newStreak));
                setCurrentStreak(newStreak);
                return newStreak;
            };

            const checkForPRs = (paceSeconds, distanceNum, durationSeconds) => {
                const newPRs = {};
                if (!personalRecords.fastestPace || paceSeconds < personalRecords.fastestPace) {
                    newPRs.fastestPace = true;
                }
                if (!personalRecords.longestDistance || distanceNum > personalRecords.longestDistance) {
                    newPRs.longestDistance = true;
                }
                if (!personalRecords.longestDuration || durationSeconds > personalRecords.longestDuration) {
                    newPRs.longestDuration = true;
                }
                setIsNewPR(newPRs);
                return newPRs;
            };

            const updatePersonalRecords = async (paceSeconds, distanceNum, durationSeconds) => {
                const newPRs = {
                    fastestPace: !personalRecords.fastestPace ? paceSeconds : Math.min(personalRecords.fastestPace, paceSeconds),
                    longestDistance: !personalRecords.longestDistance ? distanceNum : Math.max(personalRecords.longestDistance, distanceNum),
                    longestDuration: !personalRecords.longestDuration ? durationSeconds : Math.max(personalRecords.longestDuration, durationSeconds)
                };
                await window.storage.set('personal-records', JSON.stringify(newPRs));
                setPersonalRecords(newPRs);
            };

            const updateJourney = async (runData, isLegendary = false) => {
                let journey = currentJourney;
                
                if (!journey) {
                    journey = {
                        startDate: new Date().toISOString(),
                        runs: [],
                        totalDistance: 0,
                        totalDuration: 0,
                        bestPace: null,
                        prCount: 0,
                        maxStreak: 0,
                        legendaryEncounters: 0
                    };
                }
                
                journey.runs.push(runData);
                journey.totalDistance += runData.distance;
                journey.totalDuration += runData.duration;
                journey.bestPace = !journey.bestPace ? runData.pace : Math.min(journey.bestPace, runData.pace);
                journey.prCount += runData.newPRs.length;
                journey.maxStreak = Math.max(journey.maxStreak, currentStreak.days);
                
                if (isLegendary) {
                    journey.legendaryEncounters++;
                    journey.endDate = new Date().toISOString();
                    journey.legendary = {
                        id: runData.pokemonId,
                        name: pokemonData.name,
                        isShiny: runData.isShiny
                    };
                    
                    const completedJourneyData = { ...journey };
                    setCompletedJourney(completedJourneyData);
                    
                    const updatedJourneyHistory = [...journeyHistory, completedJourneyData];
                    await window.storage.set('journey-history', JSON.stringify(updatedJourneyHistory));
                    setJourneyHistory(updatedJourneyHistory);
                    
                    await window.storage.set('current-journey', 'null');
                    setCurrentJourney(null);
                    setShowJourneyModal(true);
                    
                    return completedJourneyData;
                } else {
                    await window.storage.set('current-journey', JSON.stringify(journey));
                    setCurrentJourney(journey);
                    return journey;
                }
            };

            const calculateIntensity = (paceSeconds, distanceNum, durationSeconds) => {
                let intensity = 0;
                if (paceSeconds < 360) intensity += 40;
                else if (paceSeconds < 420) intensity += 35;
                else if (paceSeconds < 480) intensity += 30;
                else if (paceSeconds < 540) intensity += 25;
                else if (paceSeconds < 600) intensity += 20;
                else intensity += 15;
                
                if (distanceNum >= 26.2) intensity += 40;
                else if (distanceNum >= 13.1) intensity += 35;
                else if (distanceNum >= 10) intensity += 30;
                else if (distanceNum >= 6.2) intensity += 25;
                else if (distanceNum >= 3.1) intensity += 20;
                else if (distanceNum >= 1) intensity += 15;
                else intensity += 10;
                
                const minutes = durationSeconds / 60;
                if (minutes >= 120) intensity += 20;
                else if (minutes >= 60) intensity += 17;
                else if (minutes >= 30) intensity += 14;
                else intensity += 10;
                
                return Math.min(100, intensity);
            };

            const RARITY_TIERS = {
                common: { name: 'Common', minGen: 1, maxGen: 2, color: 'gray', chance: 0.50 },
                uncommon: { name: 'Uncommon', minGen: 3, maxGen: 4, color: 'green', chance: 0.30 },
                rare: { name: 'Rare', minGen: 5, maxGen: 6, color: 'blue', chance: 0.15 },
                epic: { name: 'Epic', minGen: 7, maxGen: 8, color: 'purple', chance: 0.04 },
                legendary: { name: 'Legendary', minGen: 1, maxGen: 9, legendary: true, color: 'orange', chance: 0.01 }
            };

            const calculateRarityChances = (intensity, streak, newPRs) => {
                let chances = { ...RARITY_TIERS };
                const intensityMultiplier = 1 + (intensity / 50);
                const dayStreakMultiplier = 1 + (Math.min(streak.days, 30) * 0.05);
                const weekStreakMultiplier = 1 + (Math.min(streak.weeks, 10) * 0.1);
                const prCount = Object.values(newPRs).filter(Boolean).length;
                const prMultiplier = 1 + (prCount * 0.5);
                const totalMultiplier = intensityMultiplier * dayStreakMultiplier * weekStreakMultiplier * prMultiplier;
                
                const adjustedChances = {
                    common: { ...chances.common, chance: Math.max(0.1, chances.common.chance / totalMultiplier) },
                    uncommon: { ...chances.uncommon, chance: chances.uncommon.chance * 1.2 },
                    rare: { ...chances.rare, chance: chances.rare.chance * totalMultiplier * 0.8 },
                    epic: { ...chances.epic, chance: chances.epic.chance * totalMultiplier * 1.2 },
                    legendary: { ...chances.legendary, chance: Math.min(0.25, chances.legendary.chance * totalMultiplier * 2) }
                };
                
                const total = Object.values(adjustedChances).reduce((sum, tier) => sum + tier.chance, 0);
                Object.keys(adjustedChances).forEach(key => {
                    adjustedChances[key].chance = adjustedChances[key].chance / total;
                });
                
                return { chances: adjustedChances, multiplier: totalMultiplier };
            };

            const rollRarity = (chances) => {
                const roll = Math.random();
                let cumulative = 0;
                for (const [tier, data] of Object.entries(chances)) {
                    cumulative += data.chance;
                    if (roll <= cumulative) return { tier, ...data };
                }
                return { tier: 'common', ...chances.common };
            };

            const LEGENDARY_IDS = [144, 145, 146, 150, 151, 243, 244, 245, 249, 250, 377, 378, 379, 380, 381, 382, 383, 384, 480, 481, 482, 483, 484, 485, 486, 487, 488, 638, 639, 640, 641, 642, 643, 644, 645, 646, 716, 717, 718, 785, 786, 787, 788, 789, 790, 791, 792, 888, 889, 890, 891, 892, 894, 895, 896, 897, 898];

            const getPokemonByRarity = async (rarity) => {
                let pokemonId;
                if (rarity.tier === 'legendary') {
                    pokemonId = LEGENDARY_IDS[Math.floor(Math.random() * LEGENDARY_IDS.length)];
                } else {
                    const genStart = (rarity.minGen - 1) * 151 + 1;
                    const genEnd = rarity.maxGen * 151;
                    pokemonId = Math.floor(Math.random() * (genEnd - genStart + 1)) + genStart;
                    pokemonId = Math.min(898, pokemonId);
                }
                
                const baseShinyChance = 1/4096;
                const streakBonus = currentStreak.days * (1/500);
                const shinyChance = Math.min(0.1, baseShinyChance + streakBonus);
                const isShinyRoll = Math.random() < shinyChance;
                setIsShiny(isShinyRoll);
                
                return { pokemonId, isShiny: isShinyRoll, shinyChance };
            };

            const generatePokemon = async () => {
                setIsLoading(true);
                try {
                    const [paceMin, paceSec] = pace.split(':').map(Number);
                    const paceSeconds = (paceMin * 60) + (paceSec || 0);
                    const distanceNum = parseFloat(distance);
                    const [durMin, durSec] = duration.split(':').map(Number);
                    const durationSeconds = (durMin * 60) + (durSec || 0);
                    
                    const newPRs = checkForPRs(paceSeconds, distanceNum, durationSeconds);
                    const updatedStreak = await updateStreak();
                    const intensity = calculateIntensity(paceSeconds, distanceNum, durationSeconds);
                    const { chances, multiplier } = calculateRarityChances(intensity, updatedStreak, newPRs);
                    const rarity = rollRarity(chances);
                    const { pokemonId, isShiny, shinyChance } = await getPokemonByRarity(rarity);
                    
                    const newRun = {
                        date: new Date().toISOString(),
                        pace: paceSeconds,
                        distance: distanceNum,
                        duration: durationSeconds,
                        intensity,
                        rarity: rarity.tier,
                        pokemonId,
                        isShiny,
                        newPRs: Object.keys(newPRs).filter(key => newPRs[key])
                    };
                    
                    await saveRunHistory(newRun);
                    await updatePersonalRecords(paceSeconds, distanceNum, durationSeconds);
                    
                    const isLegendary = rarity.tier === 'legendary';
                    await fetchPokemonData(pokemonId);
                    
                    setRarityRoll({
                        tier: rarity.tier,
                        color: rarity.color,
                        intensity,
                        multiplier,
                        chances,
                        shinyChance: (shinyChance * 100).toFixed(2)
                    });
                    
                    setTimeout(async () => {
                        await updateJourney(newRun, isLegendary);
                        setIsLoading(false);
                    }, 100);
                } catch (error) {
                    console.error('Error:', error);
                    setIsLoading(false);
                }
            };

            const fetchPokemonData = async (pokemonId) => {
                try {
                    const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${pokemonId}`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    setPokemonData(data);

                    const variants = [];
                    if (data.sprites.front_default) variants.push({ name: 'Default', key: 'front_default', url: data.sprites.front_default });
                    if (data.sprites.front_shiny) variants.push({ name: 'Shiny ‚ú®', key: 'front_shiny', url: data.sprites.front_shiny });
                    
                    setAvailableVariants(variants);
                    setSpriteVariant(isShiny && data.sprites.front_shiny ? 'front_shiny' : variants[0]?.key || 'front_default');
                } catch (error) {
                    console.error('Error fetching Pokemon:', error);
                }
            };

            useEffect(() => {
                if (pokemonData) generateImage();
            }, [pokemonData, spriteVariant]);

            const getCurrentSpriteUrl = () => {
                if (!pokemonData) return null;
                const variant = availableVariants.find(v => v.key === spriteVariant);
                return variant ? variant.url : pokemonData.sprites.front_default;
            };

            const generateImage = () => {
                const canvas = canvasRef.current;
                if (!canvas || !pokemonData) return;

                const ctx = canvas.getContext('2d');
                const width = 1080;
                const height = 1080;
                canvas.width = width;
                canvas.height = height;

                ctx.fillStyle = '#C5C9B8';
                ctx.fillRect(0, 0, width, height);

                const spriteUrl = getCurrentSpriteUrl();
                if (spriteUrl) {
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.onload = () => {
                        const scale = 6;
                        const spriteWidth = img.width * scale;
                        const spriteHeight = img.height * scale;
                        const spriteX = (width - spriteWidth) / 2;
                        const spriteY = 180;
                        
                        ctx.imageSmoothingEnabled = false;
                        
                        if (isShiny) {
                            ctx.shadowColor = '#FFD700';
                            ctx.shadowBlur = 30;
                            for (let i = 0; i < 5; i++) {
                                ctx.drawImage(img, spriteX, spriteY, spriteWidth, spriteHeight);
                            }
                            ctx.shadowBlur = 0;
                        }
                        
                        ctx.drawImage(img, spriteX, spriteY, spriteWidth, spriteHeight);
                        
                        if (rarityRoll) {
                            const badgeY = spriteY - 60;
                            ctx.fillStyle = getRarityColor(rarityRoll.color);
                            ctx.font = 'bold 32px Arial';
                            ctx.textAlign = 'center';
                            const badgeText = isShiny ? `‚ú® SHINY ${rarityRoll.tier.toUpperCase()} ‚ú®` : rarityRoll.tier.toUpperCase();
                            ctx.fillText(badgeText, width / 2, badgeY);
                        }
                        
                        ctx.fillStyle = '#666666';
                        ctx.font = '20px monospace';
                        ctx.textAlign = 'left';
                        const timestamp = new Date().toLocaleString();
                        ctx.fillText(timestamp, spriteX - 60, spriteY + spriteHeight + 120);
                        
                        drawStatsBox(ctx, width, height);
                    };
                    img.src = spriteUrl;
                }
            };

            const getRarityColor = (color) => {
                const colors = { gray: '#6B7280', green: '#10B981', blue: '#3B82F6', purple: '#8B5CF6', orange: '#F59E0B' };
                return colors[color] || colors.gray;
            };

            const drawStatsBox = (ctx, width, height) => {
                const boxWidth = 800;
                const boxHeight = 220;
                const boxX = (width - boxWidth) / 2;
                const boxY = height - 300;

                ctx.fillStyle = '#000000';
                ctx.fillRect(boxX - 8, boxY - 8, boxWidth + 16, boxHeight + 16);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(boxX - 4, boxY - 4, boxWidth + 8, boxHeight + 8);
                ctx.fillStyle = '#E8E8D0';
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

                ctx.fillStyle = '#000000';
                ctx.font = 'bold 56px Arial';
                ctx.textAlign = 'left';
                
                const padding = 40;
                let textY = boxY + padding + 50;
                
                ctx.fillText(`Avg Pace ${pace} min/mi`, boxX + padding, textY);
                textY += 70;
                ctx.fillText(`Distance ${distance} mi`, boxX + padding, textY);
                textY += 70;
                ctx.fillText(`Duration ${duration}`, boxX + padding, textY);
            };

            const downloadImage = () => {
                const canvas = canvasRef.current;
                const link = document.createElement('a');
                link.download = `run-${pokemonData?.name || 'pokemon'}.png`;
                link.href = canvas.toDataURL();
                link.click();
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 p-4 pb-20">
                    <div className="max-w-2xl mx-auto">
                        <div className="text-center mb-6">
                            <h1 className="text-3xl md:text-4xl font-bold bg-gradient-to-r from-indigo-600 via-purple-600 to-pink-600 bg-clip-text text-transparent mb-2">
                                Pok√©Run Journey
                            </h1>
                            <p className="text-sm text-gray-600">Track runs ‚Ä¢ Catch Pok√©mon ‚Ä¢ Complete journeys</p>
                        </div>

                        {/* Compact Stats */}
                        <div className="grid grid-cols-2 gap-3 mb-6">
                            <div className="bg-gradient-to-br from-orange-500 to-red-500 rounded-xl p-3 text-white shadow-lg">
                                <div className="text-xs font-semibold mb-1">üî• Streak</div>
                                <div className="text-2xl font-bold">{currentStreak.days}d</div>
                            </div>
                            <div className="bg-gradient-to-br from-purple-500 to-pink-500 rounded-xl p-3 text-white shadow-lg">
                                <div className="text-xs font-semibold mb-1">üèÉ Runs</div>
                                <div className="text-2xl font-bold">{runHistory.length}</div>
                            </div>
                        </div>

                        {/* Input Form */}
                        <div className="bg-white rounded-2xl shadow-lg p-6 mb-6">
                            <h2 className="text-xl font-bold text-gray-800 mb-4">Your Run</h2>
                            
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-semibold text-gray-700 mb-2">Pace (min/mi)</label>
                                    <input type="text" value={pace} onChange={(e) => setPace(e.target.value)} 
                                           className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-lg" placeholder="8:53" />
                                </div>

                                <div>
                                    <label className="block text-sm font-semibold text-gray-700 mb-2">Distance (miles)</label>
                                    <input type="text" value={distance} onChange={(e) => setDistance(e.target.value)}
                                           className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-lg" placeholder="1.82" />
                                </div>

                                <div>
                                    <label className="block text-sm font-semibold text-gray-700 mb-2">Duration (mm:ss)</label>
                                    <input type="text" value={duration} onChange={(e) => setDuration(e.target.value)}
                                           className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-lg" placeholder="16:27" />
                                </div>

                                <button onClick={generatePokemon} disabled={isLoading}
                                    className="w-full py-4 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white rounded-lg font-bold text-lg transition shadow-lg disabled:opacity-50">
                                    {isLoading ? '‚è≥ Rolling...' : '‚ú® Roll for Pok√©mon!'}
                                </button>
                            </div>
                        </div>

                        {/* Results */}
                        {pokemonData && (
                            <div className="bg-white rounded-2xl shadow-lg p-6">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-xl font-bold capitalize">{pokemonData.name}</h2>
                                    {isShiny && <span className="px-3 py-1 bg-yellow-400 text-white rounded-lg font-bold text-sm">‚ú® SHINY</span>}
                                </div>
                                
                                <div className="bg-gray-100 rounded-lg p-4 mb-4">
                                    <canvas ref={canvasRef} className="w-full h-auto rounded-lg" style={{ maxHeight: '400px' }} />
                                </div>

                                <button onClick={downloadImage}
                                    className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg font-medium transition">
                                    üì• Download Image
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<PokemonRunTracker />);
    </script>
</body>
</html>
