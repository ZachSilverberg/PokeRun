<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#8B5CF6" />
  <title>Pok√©Run - Legendary Journey Tracker</title>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    * { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
    body { overscroll-behavior: none; -webkit-font-smoothing: antialiased; }
    input { font-size: 16px !important; } /* Prevents iOS zoom */
    button { cursor: pointer; -webkit-touch-callout: none; }

    #loading {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.3s;
    }
    #loading.hidden { opacity: 0; pointer-events: none; }
    .loader {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255,255,255,0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>

<body>
  <div id="loading"><div class="loader"></div></div>
  <div id="root"></div>

  <script type="text/babel">
    console.log('Script starting...');
    const { useState, useRef, useEffect } = React;

    // Storage API shim
    if (!window.storage) {
      window.storage = {
        async get(key) {
          const value = localStorage.getItem(key);
          return value ? { key, value, shared: false } : null;
        },
        async set(key, value) {
          localStorage.setItem(key, value);
          return { key, value, shared: false };
        }
      };
    }

    // Legendary pool (kept from your version)
    const LEGENDARY_IDS = [
      144,145,146,150,151,243,244,245,249,250,377,378,379,380,381,382,383,384,
      480,481,482,483,484,485,486,487,488,638,639,640,641,642,643,644,645,646,
      716,717,718,785,786,787,788,789,790,791,792,800,801,802,807,808,809,
      888,889,890,891,892,893,894,895,896,897,898
    ];

    // Single rarity tier config (no redeclare)
    const RARITY_TIERS = {
      common:    { name: 'Common',    color: 'gray',   chance: 0.50, minId: 1,   maxId: 251 },
      uncommon:  { name: 'Uncommon',  color: 'green',  chance: 0.30, minId: 252, maxId: 493 },
      rare:      { name: 'Rare',      color: 'blue',   chance: 0.15, minId: 494, maxId: 721 },
      epic:      { name: 'Epic',      color: 'purple', chance: 0.04, minId: 722, maxId: 898 },
      legendary: { name: 'Legendary', color: 'orange', chance: 0.01, legendary: true }
    };

    const PokemonRunTracker = () => {
      const [pace, setPace] = useState('');
      const [distance, setDistance] = useState('');
      const [duration, setDuration] = useState('');

      const [pokemonData, setPokemonData] = useState(null);
      const [spriteVariant, setSpriteVariant] = useState('front_default');
      const [availableVariants, setAvailableVariants] = useState([]);
      const [isShiny, setIsShiny] = useState(false);

      const [runHistory, setRunHistory] = useState([]);
      const [currentStreak, setCurrentStreak] = useState({ days: 0, weeks: 0 });
      const [personalRecords, setPersonalRecords] = useState({
        fastestPace: null,
        longestDistance: null,
        longestDuration: null
      });
      const [rarityRoll, setRarityRoll] = useState(null);
      const [isNewPR, setIsNewPR] = useState({});
      const [isLoading, setIsLoading] = useState(false);

      const canvasRef = useRef(null);

      // --- helpers (pace/duration auto-calc) ---
      const isFieldEmpty = (value) => {
        return !value || value === '' || value === '0' || value === '0:00' || value === '0.0';
      };

      const parseTimeToSeconds = (mmss) => {
        const parts = String(mmss || '').split(':');
        if (parts.length < 1) return null;
        const m = Number(parts[0]);
        const s = Number(parts[1] ?? 0);
        if (!Number.isFinite(m) || !Number.isFinite(s) || m < 0 || s < 0 || s >= 60) return null;
        return (m * 60) + s;
      };

      const formatSecondsToMMSS = (totalSeconds) => {
        const t = Math.max(0, Math.round(totalSeconds));
        const m = Math.floor(t / 60);
        const s = t % 60;
        return `${m}:${String(s).padStart(2, '0')}`;
      };

      const handlePaceChange = (value) => {
        setPace(value);

        // Only calculate duration if it's currently empty
        if (distance && value && isFieldEmpty(duration)) {
          const paceSeconds = parseTimeToSeconds(value);
          const dist = parseFloat(distance);
          if (paceSeconds != null && Number.isFinite(dist) && dist > 0) {
            setDuration(formatSecondsToMMSS(paceSeconds * dist));
          }
        }
      };

      const handleDistanceChange = (value) => {
        setDistance(value);
        const dist = parseFloat(value);
        if (!Number.isFinite(dist) || dist <= 0) return;

        // Priority 1: pace empty but duration exists -> calculate pace
        if (isFieldEmpty(pace) && !isFieldEmpty(duration)) {
          const durSeconds = parseTimeToSeconds(duration);
          if (durSeconds != null) {
            setPace(formatSecondsToMMSS(durSeconds / dist));
          }
        }
        // Priority 2: duration empty but pace exists -> calculate duration
        else if (isFieldEmpty(duration) && !isFieldEmpty(pace)) {
          const paceSeconds = parseTimeToSeconds(pace);
          if (paceSeconds != null) {
            setDuration(formatSecondsToMMSS(paceSeconds * dist));
          }
        }
      };

      const handleDurationChange = (value) => {
        setDuration(value);

        // Only calculate pace if it's currently empty
        if (distance && value && isFieldEmpty(pace)) {
          const durSeconds = parseTimeToSeconds(value);
          const dist = parseFloat(distance);
          if (durSeconds != null && Number.isFinite(dist) && dist > 0) {
            setPace(formatSecondsToMMSS(durSeconds / dist));
          }
        }
      };

      // --- persistence ---
      useEffect(() => {
        (async () => {
          await loadRunHistory();
          setTimeout(() => {
            const el = document.getElementById('loading');
            if (el) el.classList.add('hidden');
          }, 300);
        })();
      }, []);

      const loadRunHistory = async () => {
        try {
          const historyResult = await window.storage.get('run-history');
          const streakResult = await window.storage.get('current-streak');
          const prResult = await window.storage.get('personal-records');

          if (historyResult?.value) setRunHistory(JSON.parse(historyResult.value));
          if (streakResult?.value) setCurrentStreak(JSON.parse(streakResult.value));
          if (prResult?.value) setPersonalRecords(JSON.parse(prResult.value));
        } catch (e) {
          console.log('Starting fresh');
        }
      };

      const saveRunHistory = async (newRun) => {
        const updatedHistory = [...runHistory, newRun];
        await window.storage.set('run-history', JSON.stringify(updatedHistory));
        setRunHistory(updatedHistory);
        return updatedHistory;
      };

      const saveStreak = async (streak) => {
        await window.storage.set('current-streak', JSON.stringify(streak));
        setCurrentStreak(streak);
      };

      const savePersonalRecords = async (prs) => {
        await window.storage.set('personal-records', JSON.stringify(prs));
        setPersonalRecords(prs);
      };

      // --- streak ---
      const computeNextStreak = (history) => {
        const todayStr = new Date().toDateString();
        const lastRunDate = history.length > 0 ? new Date(history[history.length - 1].date).toDateString() : null;

        // If already ran today, don't increment
        if (lastRunDate === todayStr) return { ...currentStreak };

        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayStr = yesterday.toDateString();

        let next = { ...currentStreak };
        if (lastRunDate === yesterdayStr || history.length === 0) {
          next.days = (currentStreak.days || 0) + 1;
        } else {
          next.days = 1;
        }
        next.weeks = Math.floor(next.days / 7);
        return next;
      };

      // --- PRs ---
      const checkForPRs = (paceSeconds, distanceNum, durationSeconds) => {
        const newPRs = {};
        if (!personalRecords.fastestPace || paceSeconds < personalRecords.fastestPace) newPRs.fastestPace = true;
        if (!personalRecords.longestDistance || distanceNum > personalRecords.longestDistance) newPRs.longestDistance = true;
        if (!personalRecords.longestDuration || durationSeconds > personalRecords.longestDuration) newPRs.longestDuration = true;
        setIsNewPR(newPRs);
        return newPRs;
      };

      const updatePersonalRecords = async (paceSeconds, distanceNum, durationSeconds) => {
        const newPRs = {
          fastestPace: personalRecords.fastestPace == null ? paceSeconds : Math.min(personalRecords.fastestPace, paceSeconds),
          longestDistance: personalRecords.longestDistance == null ? distanceNum : Math.max(personalRecords.longestDistance, distanceNum),
          longestDuration: personalRecords.longestDuration == null ? durationSeconds : Math.max(personalRecords.longestDuration, durationSeconds)
        };
        await savePersonalRecords(newPRs);
        return newPRs;
      };

      // --- intensity & rarity ---
      const calculateIntensity = (paceSeconds, distanceNum, durationSeconds) => {
        let intensity = 0;

        // Pace scoring
        if (paceSeconds < 360) intensity += 40;          // < 6:00
        else if (paceSeconds < 420) intensity += 35;     // < 7:00
        else if (paceSeconds < 480) intensity += 30;     // < 8:00
        else if (paceSeconds < 540) intensity += 25;     // < 9:00
        else if (paceSeconds < 600) intensity += 20;     // <10:00
        else intensity += 15;

        // Distance scoring
        if (distanceNum >= 26.2) intensity += 40;
        else if (distanceNum >= 13.1) intensity += 35;
        else if (distanceNum >= 10) intensity += 30;
        else if (distanceNum >= 6.2) intensity += 25;
        else if (distanceNum >= 3.1) intensity += 20;
        else if (distanceNum >= 1) intensity += 15;
        else intensity += 10;

        // Duration scoring
        const minutes = durationSeconds / 60;
        if (minutes >= 120) intensity += 20;
        else if (minutes >= 60) intensity += 17;
        else if (minutes >= 30) intensity += 14;
        else intensity += 10;

        return Math.min(100, intensity);
      };

      const calculateRarityChances = (intensity, streak, newPRs) => {
        const intensityMultiplier = 1 + (intensity / 50);
        const dayStreakMultiplier = 1 + (Math.min(streak.days, 30) * 0.05);
        const weekStreakMultiplier = 1 + (Math.min(streak.weeks, 10) * 0.1);
        const prCount = Object.values(newPRs).filter(Boolean).length;
        const prMultiplier = 1 + (prCount * 0.5);

        const totalMultiplier = intensityMultiplier * dayStreakMultiplier * weekStreakMultiplier * prMultiplier;

        const adjusted = {
          common:    { ...RARITY_TIERS.common,    chance: Math.max(0.10, RARITY_TIERS.common.chance / totalMultiplier) },
          uncommon:  { ...RARITY_TIERS.uncommon,  chance: RARITY_TIERS.uncommon.chance * 1.2 },
          rare:      { ...RARITY_TIERS.rare,      chance: RARITY_TIERS.rare.chance * totalMultiplier * 0.8 },
          epic:      { ...RARITY_TIERS.epic,      chance: RARITY_TIERS.epic.chance * totalMultiplier * 1.2 },
          legendary: { ...RARITY_TIERS.legendary, chance: Math.min(0.25, RARITY_TIERS.legendary.chance * totalMultiplier * 2) }
        };

        const total = Object.values(adjusted).reduce((sum, t) => sum + t.chance, 0);
        for (const k of Object.keys(adjusted)) adjusted[k].chance = adjusted[k].chance / total;

        return { chances: adjusted, multiplier: totalMultiplier };
      };

      const rollRarity = (chances) => {
        const roll = Math.random();
        let cumulative = 0;
        for (const [tier, data] of Object.entries(chances)) {
          cumulative += data.chance;
          if (roll <= cumulative) return { tier, ...data };
        }
        return { tier: 'common', ...chances.common };
      };

      const getPokemonByRarity = async (rarityTier, streakDays) => {
        let pokemonId;

        if (rarityTier === 'legendary') {
          pokemonId = LEGENDARY_IDS[Math.floor(Math.random() * LEGENDARY_IDS.length)];
        } else {
          const tier = RARITY_TIERS[rarityTier];
          pokemonId = Math.floor(Math.random() * (tier.maxId - tier.minId + 1)) + tier.minId;
        }

        const baseShinyChance = 1 / 4096;
        const streakBonus = (streakDays || 0) * (1 / 500);
        const shinyChance = Math.min(0.10, baseShinyChance + streakBonus);
        const shinyRoll = Math.random() < shinyChance;

        setIsShiny(shinyRoll);
        return { pokemonId, isShiny: shinyRoll, shinyChance };
      };

      // --- PokeAPI fetch ---
      const fetchPokemonData = async (pokemonId, shinyPreferred) => {
        const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${pokemonId}`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();

        setPokemonData(data);

        const variants = [];
        if (data?.sprites?.front_default) variants.push({ name: 'Default', key: 'front_default', url: data.sprites.front_default });
        if (data?.sprites?.front_shiny) variants.push({ name: 'Shiny ‚ú®', key: 'front_shiny', url: data.sprites.front_shiny });

        setAvailableVariants(variants);

        const preferShiny = !!shinyPreferred && !!data?.sprites?.front_shiny;
        setSpriteVariant(preferShiny ? 'front_shiny' : (variants[0]?.key || 'front_default'));

        return data;
      };

      // --- canvas drawing ---
      const getCurrentSpriteUrl = () => {
        if (!pokemonData) return null;
        const variant = availableVariants.find(v => v.key === spriteVariant);
        return variant?.url || pokemonData?.sprites?.front_default || null;
      };

      const drawStar = (ctx, cx, cy, spikes, outerRadius, innerRadius) => {
        let rot = Math.PI / 2 * 3;
        const step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);

        for (let i = 0; i < spikes; i++) {
          let x = cx + Math.cos(rot) * outerRadius;
          let y = cy + Math.sin(rot) * outerRadius;
          ctx.lineTo(x, y);
          rot += step;

          x = cx + Math.cos(rot) * innerRadius;
          y = cy + Math.sin(rot) * innerRadius;
          ctx.lineTo(x, y);
          rot += step;
        }
        ctx.closePath();
        ctx.fill();
      };

      const drawRarityIcon = (ctx, x, y, size, tier) => {
        ctx.save();
        switch (tier) {
          case 'common': {
            ctx.fillStyle = '#6B7280';
            ctx.beginPath();
            ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 3;
            ctx.stroke();
            break;
          }
          case 'uncommon': {
            ctx.fillStyle = '#10B981';
            ctx.beginPath();
            ctx.moveTo(x + size/2, y);
            ctx.lineTo(x + size, y + size/2);
            ctx.lineTo(x + size/2, y + size);
            ctx.lineTo(x, y + size/2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 3;
            ctx.stroke();
            break;
          }
          case 'rare': {
            ctx.fillStyle = '#3B82F6';
            drawStar(ctx, x + size/2, y + size/2, 5, size/2, size/4);
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 3;
            ctx.stroke();
            break;
          }
          case 'epic': {
            ctx.fillStyle = '#8B5CF6';
            ctx.globalAlpha = 0.7;
            drawStar(ctx, x + size/2 - 8, y + size/2, 5, size/2.2, size/4.4);
            ctx.globalAlpha = 1;
            drawStar(ctx, x + size/2 + 8, y + size/2, 5, size/2.2, size/4.4);
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.stroke();
            break;
          }
          case 'legendary': {
            ctx.fillStyle = '#F59E0B';
            drawStar(ctx, x + size/2, y + size/3, 5, size/2.5, size/5);
            drawStar(ctx, x + size/4, y + size*2/3, 5, size/3, size/6);
            drawStar(ctx, x + size*3/4, y + size*2/3, 5, size/3, size/6);
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.stroke();
            break;
          }
        }
        ctx.restore();
      };

      const drawStatsBox = (ctx, width, height) => {
        const boxWidth = 800;
        const boxHeight = 250;
        const boxX = (width - boxWidth) / 2;
        const boxY = height - 330;

        ctx.fillStyle = '#000000';
        ctx.fillRect(boxX - 8, boxY - 8, boxWidth + 16, boxHeight + 16);
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(boxX - 4, boxY - 4, boxWidth + 8, boxHeight + 8);
        ctx.fillStyle = '#E8E8D0';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

        ctx.fillStyle = '#000000';
        ctx.font = 'bold 50px Arial';
        ctx.textAlign = 'left';

        const padding = 60;
        let textY = boxY + 70;

        ctx.fillText(`Avg Pace ${pace} min/mi`, boxX + padding, textY);
        textY += 80;
        ctx.fillText(`Distance ${distance} mi`, boxX + padding, textY);
        textY += 80;
        ctx.fillText(`Duration ${duration}`, boxX + padding, textY);
      };

      const generateImage = () => {
        const canvas = canvasRef.current;
        if (!canvas || !pokemonData) return;

        const ctx = canvas.getContext('2d');
        const width = 1080;
        const height = 1080;
        canvas.width = width;
        canvas.height = height;

        ctx.fillStyle = '#C5C9B8';
        ctx.fillRect(0, 0, width, height);

        const spriteUrl = getCurrentSpriteUrl();
        if (!spriteUrl) return;

        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const scale = 6;
          const spriteWidth = img.width * scale;
          const spriteHeight = img.height * scale;
          const spriteX = (width - spriteWidth) / 2;
          const spriteY = 220;

          // Name
          ctx.fillStyle = '#000000';
          ctx.font = 'bold 48px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(String(pokemonData.name || '').toUpperCase(), width / 2, spriteY - 60);

          ctx.imageSmoothingEnabled = false;

          if (isShiny) {
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 30;
            for (let i = 0; i < 5; i++) ctx.drawImage(img, spriteX, spriteY, spriteWidth, spriteHeight);
            ctx.shadowBlur = 0;
          }

          ctx.drawImage(img, spriteX, spriteY, spriteWidth, spriteHeight);

          // Rarity Icon
          if (rarityRoll?.tier) {
            const iconSize = 60;
            const iconX = width / 2 - iconSize / 2;
            const iconY = spriteY - 180;
            drawRarityIcon(ctx, iconX, iconY, iconSize, rarityRoll.tier);
          }

          // Timestamp
          ctx.fillStyle = '#666666';
          ctx.font = '20px monospace';
          ctx.textAlign = 'left';
          const timestamp = new Date().toLocaleString();
          ctx.fillText(timestamp, spriteX - 60, spriteY + spriteHeight + 100);

          drawStatsBox(ctx, width, height);
        };
        img.onerror = () => console.error('Failed to load sprite image');
        img.src = spriteUrl;
      };

      useEffect(() => {
        if (pokemonData) generateImage();
      }, [pokemonData, spriteVariant, rarityRoll, isShiny]);

      // --- share/download ---
      const downloadImage = async () => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        try {
          canvas.toBlob(async (blob) => {
            if (!blob) return;

            if (navigator.share && navigator.canShare) {
              const file = new File([blob], `pokerun-${pokemonData?.name || 'pokemon'}.png`, { type: 'image/png' });
              if (navigator.canShare({ files: [file] })) {
                try {
                  await navigator.share({
                    files: [file],
                    title: 'My Pok√©Run',
                    text: `Caught ${pokemonData?.name || 'a Pok√©mon'}!`
                  });
                  return;
                } catch (err) {
                  console.log('Share cancelled/failed:', err);
                }
              }
            }

            const link = document.createElement('a');
            link.download = `pokerun-${pokemonData?.name || 'pokemon'}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
          }, 'image/png');
        } catch (e) {
          console.error('Error sharing:', e);
          const link = document.createElement('a');
          link.download = `pokerun-${pokemonData?.name || 'pokemon'}.png`;
          link.href = canvas.toDataURL('image/png');
          link.click();
        }
      };

      // --- main action ---
      const generatePokemon = async () => {
        setIsLoading(true);

        try {
          const paceSeconds = parseTimeToSeconds(pace);
          const distanceNum = parseFloat(distance);
          const durationSeconds = parseTimeToSeconds(duration);

          if (paceSeconds == null || durationSeconds == null || !Number.isFinite(distanceNum) || distanceNum <= 0) {
            alert('Please enter valid Pace (m:ss), Distance (>0), and Duration (m:ss). Example: 8:53, 1.82, 16:27');
            setIsLoading(false);
            return;
          }

          // PRs + streak
          const newPRs = checkForPRs(paceSeconds, distanceNum, durationSeconds);
          const nextStreak = computeNextStreak(runHistory);
          await saveStreak(nextStreak);

          const intensity = calculateIntensity(paceSeconds, distanceNum, durationSeconds);

          // Rarity roll
          const { chances, multiplier } = calculateRarityChances(intensity, nextStreak, newPRs);
          const rolled = rollRarity(chances); // { tier, color, chance... }

          // Pokemon pick + shiny roll
          const { pokemonId, isShiny: shinyRoll, shinyChance } = await getPokemonByRarity(rolled.tier, nextStreak.days);

          // Fetch pokemon (and set state)
          const fetched = await fetchPokemonData(pokemonId, shinyRoll);

          // Save run + PRs
          const newRun = {
            date: new Date().toISOString(),
            pace: paceSeconds,
            distance: distanceNum,
            duration: durationSeconds,
            intensity,
            rarity: rolled.tier,
            pokemonId,
            pokemonName: fetched?.name || 'unknown',
            isShiny: shinyRoll,
            newPRs: Object.keys(newPRs).filter(k => newPRs[k])
          };

          await saveRunHistory(newRun);
          await updatePersonalRecords(paceSeconds, distanceNum, durationSeconds);

          // UI rarity summary
          setRarityRoll({
            tier: rolled.tier,
            color: rolled.color,
            intensity,
            multiplier,
            chances,
            shinyChance: (shinyChance * 100).toFixed(2)
          });

        } catch (err) {
          console.error(err);
          alert('Something went wrong. Check console for details.');
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 p-4 pb-20">
          <div className="max-w-2xl mx-auto">

            <div className="text-center mb-6">
              <h1 className="text-3xl md:text-4xl font-bold bg-gradient-to-r from-indigo-600 via-purple-600 to-pink-600 bg-clip-text text-transparent mb-2">
                Pok√©Run Journey
              </h1>
              <p className="text-sm text-gray-600">Track runs ‚Ä¢ Catch Pok√©mon ‚Ä¢ Roll rarity</p>
            </div>

            <div className="grid grid-cols-2 gap-3 mb-6">
              <div className="bg-gradient-to-br from-orange-500 to-red-500 rounded-xl p-3 text-white shadow-lg">
                <div className="text-xs font-semibold mb-1">üî• Streak</div>
                <div className="text-2xl font-bold">{currentStreak.days}d</div>
              </div>
              <div className="bg-gradient-to-br from-purple-500 to-pink-500 rounded-xl p-3 text-white shadow-lg">
                <div className="text-xs font-semibold mb-1">üèÉ Runs</div>
                <div className="text-2xl font-bold">{runHistory.length}</div>
              </div>
            </div>

            <div className="bg-white rounded-2xl shadow-lg p-6 mb-6">
              <h2 className="text-xl font-bold text-gray-800 mb-4">Your Run</h2>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-semibold text-gray-700 mb-2">Pace (min/mi)</label>
                  <input
                    type="text"
                    value={pace}
                    onChange={(e) => handlePaceChange(e.target.value)}
                    className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-lg"
                    placeholder="8:53"
                    inputMode="numeric"
                  />
                </div>

                <div>
                  <label className="block text-sm font-semibold text-gray-700 mb-2">Distance (miles)</label>
                  <input
                    type="text"
                    value={distance}
                    onChange={(e) => handleDistanceChange(e.target.value)}
                    className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-lg"
                    placeholder="1.82"
                    inputMode="decimal"
                  />
                </div>

                <div>
                  <label className="block text-sm font-semibold text-gray-700 mb-2">Duration (mm:ss)</label>
                  <input
                    type="text"
                    value={duration}
                    onChange={(e) => handleDurationChange(e.target.value)}
                    className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-lg"
                    placeholder="16:27"
                    inputMode="numeric"
                  />
                </div>

                <button
                  onClick={generatePokemon}
                  disabled={isLoading}
                  className="w-full py-4 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white rounded-lg font-bold text-lg transition shadow-lg disabled:opacity-50"
                >
                  {isLoading ? '‚è≥ Rolling...' : '‚ú® Roll for Pok√©mon!'}
                </button>
              </div>
            </div>

            {pokemonData && (
              <div className="bg-white rounded-2xl shadow-lg p-6">
                <div className="flex justify-between items-center mb-4">
                  <h2 className="text-xl font-bold capitalize">{pokemonData.name}</h2>
                  <div className="flex gap-2">
                    {rarityRoll && (
                      <span className={`px-3 py-1 rounded-lg font-bold text-sm ${
                        rarityRoll.tier === 'legendary' ? 'bg-gradient-to-r from-yellow-400 to-orange-400 text-white' :
                        rarityRoll.tier === 'epic' ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white' :
                        rarityRoll.tier === 'rare' ? 'bg-blue-500 text-white' :
                        rarityRoll.tier === 'uncommon' ? 'bg-green-500 text-white' :
                        'bg-gray-500 text-white'
                      }`}>
                        {rarityRoll.tier.toUpperCase()}
                      </span>
                    )}
                    {isShiny && (
                      <span className="px-3 py-1 bg-yellow-400 text-white rounded-lg font-bold text-sm">
                        ‚ú® SHINY
                      </span>
                    )}
                  </div>
                </div>

                <div className="bg-gray-100 rounded-lg p-4 mb-4">
                  <canvas ref={canvasRef} className="w-full h-auto rounded-lg" style={{ maxHeight: '400px' }} />
                </div>

                <button
                  onClick={downloadImage}
                  className="w-full py-3 bg-black hover:bg-gray-900 text-white rounded-lg font-medium transition"
                >
                  Share your PokeRun
                </button>

                {rarityRoll && (
                  <div className="mt-4 text-xs text-gray-600">
                    <div><span className="font-semibold">Intensity:</span> {rarityRoll.intensity}/100</div>
                    <div><span className="font-semibold">Multiplier:</span> {rarityRoll.multiplier.toFixed(2)}x</div>
                    <div><span className="font-semibold">Shiny chance:</span> {rarityRoll.shinyChance}%</div>
                  </div>
                )}
              </div>
            )}

          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<PokemonRunTracker />);
    console.log('Render complete');
  </script>
</body>
</html>
